"use strict";(self.webpackChunktextlint_website=self.webpackChunktextlint_website||[]).push([[8664],{3482:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>x,frontMatter:()=>r,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"use-as-modules","title":"Use as Node Modules","description":"Overview","source":"@site/../docs/use-as-modules.md","sourceDirName":".","slug":"/use-as-modules","permalink":"/docs/use-as-modules","draft":false,"unlisted":false,"editUrl":"https://github.com/textlint/textlint/edit/master/docs/../docs/use-as-modules.md","tags":[],"version":"current","lastUpdatedBy":"piyo","lastUpdatedAt":1749215277000,"frontMatter":{"id":"use-as-modules","title":"Use as Node Modules"},"sidebar":"docs","previous":{"title":"Formatter","permalink":"/docs/formatter"},"next":{"title":"TxtAST Interface","permalink":"/docs/txtnode"}}');var l=n(4848),s=n(8453);const r={id:"use-as-modules",title:"Use as Node Modules"},o=void 0,c={},d=[{value:"Overview",id:"overview",level:2},{value:"CLI(Command Line Interface)",id:"clicommand-line-interface",level:3},{value:"APIs",id:"apis",level:2},{value:"Examples",id:"examples",level:2},{value:"Lint files and output to console",id:"lint-files-and-output-to-console",level:3},{value:"Fix text and get the fixed text",id:"fix-text-and-get-the-fixed-text",level:3},{value:"Add custom rules and plugins",id:"add-custom-rules-and-plugins",level:2},{value:"Get lintable file extensions",id:"get-lintable-file-extensions",level:2},{value:"Want to know the file path is lintable or not",id:"want-to-know-the-file-path-is-lintable-or-not",level:2},{value:"Deprecated APIs",id:"deprecated-apis",level:2},{value:"[Deprecated] Engine",id:"deprecated-engine",level:3},{value:"[Deprecated] <code>TextlintCore</code>",id:"deprecated-textlintcore",level:3},{value:"TextLintEngine Example",id:"textlintengine-example",level:3},{value:"Migration to New API",id:"migration-to-new-api",level:3},{value:"engine.executeOnText",id:"engineexecuteontext",level:4},{value:"Testing",id:"testing",level:2}];function a(e){const t={a:"a",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(t.h2,{id:"overview",children:"Overview"}),"\n",(0,l.jsxs)(t.p,{children:[(0,l.jsx)(t.code,{children:"textlint"})," package provides some High-Level APIs."]}),"\n",(0,l.jsxs)(t.ul,{children:["\n",(0,l.jsxs)(t.li,{children:["If you want to load ",(0,l.jsx)(t.code,{children:".textlintrc"}),", please use ",(0,l.jsx)(t.code,{children:"textlint"})," package"]}),"\n",(0,l.jsxs)(t.li,{children:["If you do not want to load ",(0,l.jsx)(t.code,{children:".textlintrc"}),", please use ",(0,l.jsx)(t.code,{children:"@textlint/kernel"})," package"]}),"\n"]}),"\n",(0,l.jsx)(t.h3,{id:"clicommand-line-interface",children:"CLI(Command Line Interface)"}),"\n",(0,l.jsx)(t.p,{children:"CLI parse command arguments, and run Engine with the options.\nIt returns exit code."}),"\n",(0,l.jsx)(t.pre,{children:(0,l.jsx)(t.code,{className:"language-js",children:'import { cli } from "textlint";\nconst result = await cli.execute(`./README.md --rule textlint-rule-no-todo`);\nassert.strictEqual(result, 0);\n'})}),"\n",(0,l.jsx)(t.h2,{id:"apis",children:"APIs"}),"\n",(0,l.jsxs)(t.p,{children:[(0,l.jsx)(t.strong,{children:"textlint v12.3.0"})," introduced a new API, and textlint and will drop support for the old API (",(0,l.jsx)(t.code,{children:"textlint"}),", ",(0,l.jsx)(t.code,{children:"TextLintEngine"}),", ",(0,l.jsx)(t.code,{children:"TextFixEngine"}),", and ",(0,l.jsx)(t.code,{children:"TextLintCore"}),") in the future. The old API does not support ECMAScript modules like the new API does. For guidance on migration, see the ",(0,l.jsx)(t.a,{href:"#migration-to-new-api",children:"migration guide"})," section below."]}),"\n",(0,l.jsxs)(t.ul,{children:["\n",(0,l.jsxs)(t.li,{children:[(0,l.jsx)(t.code,{children:"createLinter"}),": create linter instance\n",(0,l.jsxs)(t.ul,{children:["\n",(0,l.jsxs)(t.li,{children:[(0,l.jsx)(t.code,{children:"lintFiles(files): Promise<TextlintResult[]>"}),": lint files and return linter messages"]}),"\n",(0,l.jsxs)(t.li,{children:[(0,l.jsx)(t.code,{children:"lintText(text, filePath): Promise<TextlintResult>"})," lint text with virtual filePath and return linter messages\n",(0,l.jsxs)(t.ul,{children:["\n",(0,l.jsxs)(t.li,{children:["The virtual file path does not need to be a real file, rather it should hint the content type being passed to lintText. For example, if ",(0,l.jsx)(t.code,{children:"text"})," is Markdown, ",(0,l.jsx)(t.code,{children:"filePath"})," could be ",(0,l.jsx)(t.code,{children:"foo.md"}),"."]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(t.li,{children:[(0,l.jsx)(t.code,{children:"fixFiles(files): Promise<TextlintFixResult[]>"})," lint text and return fixer messages"]}),"\n",(0,l.jsxs)(t.li,{children:[(0,l.jsx)(t.code,{children:"fixText(text, filePath): Promise<TextlintFixResult>"})," lint text with virtual filePath and return fixer messages\n",(0,l.jsxs)(t.ul,{children:["\n",(0,l.jsxs)(t.li,{children:[(0,l.jsx)(t.code,{children:"fixFiles"})," and ",(0,l.jsx)(t.code,{children:"fixText"})," does not modify files"]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(t.li,{children:[(0,l.jsx)(t.code,{children:"scanFilePath(filePath): Promise<ScanFilePathResult>"})," check the the file path is lintable or not"]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(t.li,{children:[(0,l.jsx)(t.code,{children:"loadTextlintrc"}),": load ",(0,l.jsx)(t.code,{children:".textlintrc"})," config file and return a descriptor object"]}),"\n",(0,l.jsxs)(t.li,{children:[(0,l.jsx)(t.code,{children:"loadLinerFormatter"})," and ",(0,l.jsx)(t.code,{children:"loadFixerFormatter"}),": load formatter"]}),"\n"]}),"\n",(0,l.jsx)(t.h2,{id:"examples",children:"Examples"}),"\n",(0,l.jsx)(t.h3,{id:"lint-files-and-output-to-console",children:"Lint files and output to console"}),"\n",(0,l.jsx)(t.pre,{children:(0,l.jsx)(t.code,{className:"language-ts",children:'import { createLinter, loadTextlintrc, loadLinterFormatter } from "textlint";\n// descriptor is a structure object for linter\n// It includes rules, plugins, and options\nconst descriptor = await loadTextlintrc();\nconst linter = createLinter({\n    descriptor\n});\nconst results = await linter.lintFiles(["*.md"]);\n// textlint has two types formatter sets for linter and fixer\nconst formatter = await loadLinterFormatter({ formatterName: "stylish" });\nconst output = formatter.format(results);\nconsole.log(output);\n'})}),"\n",(0,l.jsx)(t.h3,{id:"fix-text-and-get-the-fixed-text",children:"Fix text and get the fixed text"}),"\n",(0,l.jsx)(t.pre,{children:(0,l.jsx)(t.code,{className:"language-ts",children:'import { createLinter, loadTextlintrc } from "textlint";\n// descriptor is a structure object for linter\n// It includes rules, plugins, and options\nconst descriptor = await loadTextlintrc();\nconst linter = createLinter({\n    descriptor\n});\nconst result = await linter.fixText("TODO: fix me", "DUMMY.md");\nconsole.log(result.output); // fixed result\n'})}),"\n",(0,l.jsx)(t.h2,{id:"add-custom-rules-and-plugins",children:"Add custom rules and plugins"}),"\n",(0,l.jsx)(t.pre,{children:(0,l.jsx)(t.code,{className:"language-ts",children:'import { createLinter, loadTextlintrc } from "textlint";\nimport { TextlintKernelDescriptor } from "@textlint/kernel";\nimport { moduleInterop } from "@textlint/module-interop";\n// Create a descriptor for custom rules and plugins\nconst customDescriptor = new TextlintKernelDescriptor({\n    rules: [\n        {\n            ruleId: "custom-rule",\n            rule: moduleInterop((await import("./custom-plugin")).default)\n        }\n    ],\n    plugins: [\n        {\n            pluginId: "custom-plugin",\n            plugin: moduleInterop((await import("./custom-plugin")).default)\n        }\n    ]\n});\nconst textlintrcDescriptor = await loadTextlintrc();\nconst linter = createLinter({\n    // merge customDescriptor and textlintrcDescriptor\n    // if same ruleId or pluginId, customDescriptor is used.\n    descriptor: customDescriptor.concat(textlintrcDescriptor)\n});\n\n// The second param should be a filename whose extension hints at the type\n// of content being passed to lintText(), e.g. README.md for Markdown.\nconst result = await linter.lintText("TODO: fix me", "README.md");\nconsole.log(result);\n\n'})}),"\n",(0,l.jsx)(t.h2,{id:"get-lintable-file-extensions",children:"Get lintable file extensions"}),"\n",(0,l.jsxs)(t.p,{children:[(0,l.jsx)(t.code,{children:"textlintrcDescriptor.availableExtensions"})," provide list of supported file extensions."]}),"\n",(0,l.jsx)(t.pre,{children:(0,l.jsx)(t.code,{className:"language-ts",children:'import { createLinter, loadTextlintrc } from "textlint";\nconst textlintrcDescriptor = await loadTextlintrc();\nconst availableExtensions = textlintrcDescriptor.availableExtensions;\nconsole.log(availableExtensions); // => [".md", ".txt"]\n'})}),"\n",(0,l.jsx)(t.h2,{id:"want-to-know-the-file-path-is-lintable-or-not",children:"Want to know the file path is lintable or not"}),"\n",(0,l.jsx)(t.pre,{children:(0,l.jsx)(t.code,{className:"language-ts",children:'import { createLinter, loadTextlintrc } from "textlint";\nconst textlintrcDescriptor = await loadTextlintrc();\nconst linter = createLinter({\n    descriptor: textlintrcDescriptor\n});\nconst result = await linter.scanFilePath("README.md");\n// result.status is "ok" or "ignored" or "error"\nif (result.status === "ok") {\n    const lintResult = await linter.lintText("README content", "README.md");\n    console.log(lintResult);\n}\n'})}),"\n",(0,l.jsx)(t.h2,{id:"deprecated-apis",children:"Deprecated APIs"}),"\n",(0,l.jsx)(t.h3,{id:"deprecated-engine",children:"[Deprecated] Engine"}),"\n",(0,l.jsxs)(t.p,{children:["textlint has two engines ",(0,l.jsx)(t.code,{children:"TextLintEngine"})," and ",(0,l.jsx)(t.code,{children:"TextFixEngine"}),"."]}),"\n",(0,l.jsx)(t.p,{children:"Both engine"}),"\n",(0,l.jsxs)(t.ul,{children:["\n",(0,l.jsxs)(t.li,{children:["Load configuration from ",(0,l.jsx)(t.code,{children:".textlintrc"}),"."]}),"\n",(0,l.jsxs)(t.li,{children:["Handle ",(0,l.jsx)(t.strong,{children:"multiple"})," files or text string."]}),"\n",(0,l.jsxs)(t.li,{children:["Return an array of ",(0,l.jsx)(t.code,{children:"TextLintResult"})," or ",(0,l.jsx)(t.code,{children:"TextLintFixResult"}),"\n",(0,l.jsxs)(t.ul,{children:["\n",(0,l.jsxs)(t.li,{children:["actually, return a Promise like ",(0,l.jsx)(t.code,{children:"Promise<TextLintResult[]>"})]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(t.h3,{id:"deprecated-textlintcore",children:["[Deprecated] ",(0,l.jsx)(t.code,{children:"TextlintCore"})]}),"\n",(0,l.jsxs)(t.p,{children:["You can use ",(0,l.jsx)(t.code,{children:"@textlint/legacy-textlint-core"})," package instead of ",(0,l.jsx)(t.code,{children:"TextlintCore"}),"."]}),"\n",(0,l.jsxs)(t.ul,{children:["\n",(0,l.jsx)(t.li,{children:"Accept configuration as object."}),"\n",(0,l.jsxs)(t.li,{children:["Handle a ",(0,l.jsx)(t.strong,{children:"single"})," file or text string."]}),"\n",(0,l.jsxs)(t.li,{children:["Return ",(0,l.jsx)(t.code,{children:"TextLintResult"})," or ",(0,l.jsx)(t.code,{children:"TextLintFixResult"}),"\n",(0,l.jsxs)(t.ul,{children:["\n",(0,l.jsxs)(t.li,{children:["actually, return a Promise like ",(0,l.jsx)(t.code,{children:"Promise<TextLintResult>"})]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(t.h3,{id:"textlintengine-example",children:"TextLintEngine Example"}),"\n",(0,l.jsxs)(t.p,{children:["Lint files using ",(0,l.jsx)(t.code,{children:"TextLintEngine"}),":"]}),"\n",(0,l.jsxs)(t.p,{children:["See ",(0,l.jsx)(t.a,{href:"https://github.com/textlint/textlint/blob/master/examples/use-as-module/index.js",children:"examples/use-as-module/index.js"})]}),"\n",(0,l.jsx)(t.pre,{children:(0,l.jsx)(t.code,{className:"language-js",children:'const TextLintEngine = require("textlint").TextLintEngine;\nconst path = require("path");\n\nfunction lintFile(filePath) {\n    const options = {\n        // load rules from [../rules]\n        rules: ["no-todo"],\n        formatterName: "pretty-error"\n    };\n    const engine = new TextLintEngine(options);\n    const filePathList = [path.resolve(process.cwd(), filePath)];\n    return engine.executeOnFiles(filePathList).then(function(results) {\n        if (engine.isErrorResults(results)) {\n            const output = engine.formatResults(results);\n            console.log(output);\n        } else {\n            console.log("All Passed!");\n        }\n    });\n}\n\nlintFile(`${__dirname}/README.md`).catch(function(error) {\n    console.error(error);\n    process.exit(1);\n});\n'})}),"\n",(0,l.jsx)(t.h3,{id:"migration-to-new-api",children:"Migration to New API"}),"\n",(0,l.jsx)(t.p,{children:"To migrate to the new API from the old API, you may need to make additional changes beyond just changing to a different method."}),"\n",(0,l.jsx)(t.p,{children:"Old API:"}),"\n",(0,l.jsx)(t.pre,{children:(0,l.jsx)(t.code,{className:"language-js",children:'const TextLintEngine = require("textlint").TextLintEngine;\n// Rely on textlint finding the config automatically.\nconst engine = new TextLintEngine();\n'})}),"\n",(0,l.jsx)(t.p,{children:"New API:"}),"\n",(0,l.jsx)(t.pre,{children:(0,l.jsx)(t.code,{className:"language-js",children:'// Import node helpers to get the config path.\nimport path from "node:path";\nimport { cwd } from "node:process";\nimport { createLinter, loadTextlintrc } from "textlint";\n\n// Load config using helpers to pass into createLinter().\nconst descriptor = await loadTextlintrc({\n    configFilePath: path.join(cwd(), ".textlintrc.json")\n});\nconst linter = createLinter({\n    descriptor\n});\n'})}),"\n",(0,l.jsx)(t.h4,{id:"engineexecuteontext",children:"engine.executeOnText"}),"\n",(0,l.jsxs)(t.p,{children:["Replace with ",(0,l.jsx)(t.code,{children:"linter.lintText()"}),":"]}),"\n",(0,l.jsx)(t.p,{children:"Old API:"}),"\n",(0,l.jsx)(t.pre,{children:(0,l.jsx)(t.code,{className:"language-js",children:'const ruleText = "Tihs is my text.";\nconst results = await engine.executeOnText(ruleText);\n'})}),"\n",(0,l.jsx)(t.p,{children:"New API -- dummy filename to determine content type."}),"\n",(0,l.jsx)(t.pre,{children:(0,l.jsx)(t.code,{className:"language-js",children:"const ruleText = \"Tihs is my text.\";\nconst results = await linter.lintText(ruleText, 'dummy.txt');\n"})}),"\n",(0,l.jsx)(t.h2,{id:"testing",children:"Testing"}),"\n",(0,l.jsxs)(t.p,{children:["You can use ",(0,l.jsx)(t.a,{href:"https://www.npmjs.com/package/textlint-tester",children:"textlint-tester"})," for testing your custom rule."]}),"\n",(0,l.jsxs)(t.ul,{children:["\n",(0,l.jsx)(t.li,{children:(0,l.jsx)(t.a,{href:"/docs/rule",children:"rule.md"})}),"\n",(0,l.jsx)(t.li,{children:(0,l.jsx)(t.a,{href:"https://www.npmjs.com/package/textlint-tester",title:"textlint-tester",children:"textlint-tester"})}),"\n"]}),"\n",(0,l.jsx)(t.p,{children:"Consult link:"}),"\n",(0,l.jsxs)(t.ul,{children:["\n",(0,l.jsx)(t.li,{children:(0,l.jsx)(t.a,{href:"https://github.com/azu/textlint-rule-spellcheck-tech-word/blob/master/test/test.js",title:"spellcheck-tech-word-textlint-rule/test.js at master \xb7 azu/spellcheck-tech-word-textlint-rule",children:"spellcheck-tech-word-textlint-rule/test.js at master \xb7 azu/spellcheck-tech-word-textlint-rule"})}),"\n"]})]})}function x(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,l.jsx)(t,{...e,children:(0,l.jsx)(a,{...e})}):a(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>o});var i=n(6540);const l={},s=i.createContext(l);function r(e){const t=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:r(e.components),i.createElement(s.Provider,{value:t},e.children)}}}]);